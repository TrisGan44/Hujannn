<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Crystal Light Column</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  html,body{height:100%}
  body{background:#000;overflow:hidden;color:#9cf;font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial}
  #fx{position:fixed;inset:0;width:100%;height:100%;filter:saturate(1.35) contrast(1.2)}
  .hint{position:fixed;left:12px;bottom:12px;opacity:.7;font-size:12px}
  .hint b{color:#fff}
</style>
</head>
<body>
<canvas id="fx"></canvas>
<div class="hint">Drag to warp • Click to reshuffle • <b>Esc</b> to pause</div>
<script>
(() => {
  const cvs = document.getElementById('fx');
  const ctx = cvs.getContext('2d', { alpha:true });
  const tmp = document.createElement('canvas');
  const tctx = tmp.getContext('2d');

  let DPR = 1, W = 0, H = 0, CX = 0, CY = 0;
  const resize = () => {
    DPR = Math.min(window.devicePixelRatio || 1, 2.5);
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    CX = W * 0.5; CY = H * 0.5;
    cvs.width = W; cvs.height = H; cvs.style.width = innerWidth + 'px'; cvs.style.height = innerHeight + 'px';
    tmp.width = Math.ceil(W/2); tmp.height = Math.ceil(H/2); // for bloom
  };
  addEventListener('resize', resize, {passive:true}); resize();

  const rand = (a,b)=>a+Math.random()*(b-a);
  const nrand = (s=1)=> (Math.random()*2-1)*s;
  const now = ()=>performance.now();

  const palette = {
    core:'#79f5ff',
    core2:'#00d2ff',
    deep:'#0080ff',
    teal:'#00b3b3',
    white:'#ffffff'
  };

  // Geometry for the crystal: a vertical column with faceted quads and shards
  function makeCrystal(seed=0){
    const column = [];
    const shards = [];
    const columnWidth = rand(90,130) * DPR;
    const columnHeight = Math.max(H*0.75, 520*DPR);
    const rows = 16;
    const step = columnHeight/rows;
    const skew = rand(-0.15,0.15);
    for(let i=0;i<rows;i++){
      const y = CY + (i-rows/2+0.5)*step;
      const w = columnWidth * (0.85 + 0.25*Math.sin(i*0.7 + seed));
      const h = step * rand(0.85,1.3);
      const x = CX + (i-rows/2)*step*skew;
      column.push({x,y,w,h, r:rand(0.02,0.06)});
      // add a couple of side shards around some rows
      if(Math.random()<0.75){
        const side = Math.random()<0.5? -1: 1;
        const sw = w*rand(0.25,0.55);
        const sh = h*rand(0.4,0.9);
        const sx = x + side*(w*0.6 + rand(12,32)*DPR);
        const sy = y + nrand(step*0.25);
        shards.push({x:sx,y:sy,w:sw,h:sh, side});
      }
    }
    return {column, shards, width:columnWidth, height:columnHeight};
  }

  let crystal = makeCrystal(Math.random()*10);

  // Simple 2D noise via layered sin/cos
  function noise2(x,y,t){
    const s1 = Math.sin(x*0.004 + t*0.0006) * Math.cos(y*0.005 - t*0.0004);
    const s2 = Math.cos(x*0.007 - t*0.0003) * Math.sin(y*0.006 + t*0.0005);
    const s3 = Math.sin((x+y)*0.002 + t*0.0009);
    return (s1*0.6 + s2*0.3 + s3*0.1);
  }

  // Draw a beveled rectangle with inner highlight and edge glow
  function drawFacet(g, x, y, w, h, t, tintA, tintB, bevel=0.23){
    g.save();
    g.translate(x,y);
    // body gradient
    const gg = g.createLinearGradient(-w*0.5, -h*0.5, w*0.5, h*0.5);
    gg.addColorStop(0, tintB);
    gg.addColorStop(0.5, tintA);
    gg.addColorStop(1, tintB);
    g.fillStyle = gg;
    g.globalAlpha = 0.88;
    roundRect(g, -w*0.5, -h*0.5, w, h, Math.min(w,h)*bevel);
    g.fill();

    // inner highlight line
    const gx = g.createLinearGradient(-w*0.5, 0, w*0.5, 0);
    gx.addColorStop(0, 'rgba(255,255,255,0)');
    gx.addColorStop(0.5, 'rgba(255,255,255,0.35)');
    gx.addColorStop(1, 'rgba(255,255,255,0)');
    g.fillStyle = gx;
    g.globalAlpha = 0.8;
    roundRect(g, -w*0.5+1, -2, w-2, 4, 2);
    g.fill();

    // edge glow
    g.globalAlpha = 0.65;
    g.strokeStyle = 'rgba(120,245,255,0.7)';
    g.lineWidth = 1.2 * DPR;
    roundRect(g, -w*0.5, -h*0.5, w, h, Math.min(w,h)*bevel);
    g.stroke();

    // small sparkle
    const sp = 5*DPR;
    g.globalAlpha = 0.9;
    g.fillStyle = '#fff';
    g.fillRect(-sp*0.5, -sp*0.5, sp, sp);
    g.restore();
  }

  function roundRect(g, x, y, w, h, r){
    const rr = Math.max(0, Math.min(r, Math.min(w,h)*0.5));
    g.beginPath();
    g.moveTo(x+rr, y);
    g.lineTo(x+w-rr, y);
    g.quadraticCurveTo(x+w, y, x+w, y+rr);
    g.lineTo(x+w, y+h-rr);
    g.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    g.lineTo(x+rr, y+h);
    g.quadraticCurveTo(x, y+h, x, y+h-rr);
    g.lineTo(x, y+rr);
    g.quadraticCurveTo(x, y, x+rr, y);
    g.closePath();
  }

  // Particles: drifting squares and tiny glints
  const particles = Array.from({length:42}).map(()=>({
    x:CX + nrand(220*DPR),
    y:CY + nrand(360*DPR),
    vx:nrand(0.06*DPR),
    vy:nrand(0.10*DPR),
    s:rand(1,3.2)*DPR,
    a:rand(0.2,0.6),
    c:Math.random()<0.65? '#00ffff':'#00d2ff',
    p:rand(0,Math.PI*2),
    sp:rand(0.001,0.004)
  }));

  let paused = false;
  addEventListener('keydown', e=>{ if(e.key==='Escape') paused=!paused; });
  addEventListener('click', ()=>{ crystal = makeCrystal(Math.random()*10); });
  let drag=false, mx=0,my=0; 
  addEventListener('pointerdown', e=>{drag=true; mx=e.clientX; my=e.clientY;});
  addEventListener('pointerup', ()=>drag=false);
  addEventListener('pointermove', e=>{ if(drag){ mx=e.clientX; my=e.clientY; }});

  // bloom helper: draw into tmp at half res then blur by scaling
  function applyBloom(){
    tctx.clearRect(0,0,tmp.width,tmp.height);
    tctx.globalCompositeOperation='source-over';
    tctx.globalAlpha = 1;
    tctx.drawImage(cvs, 0,0, tmp.width, tmp.height);
    // two passes of cheap blur via scaling
    const w = Math.max(1, Math.floor(tmp.width*0.6));
    const h = Math.max(1, Math.floor(tmp.height*0.6));
    const t2 = document.createElement('canvas');
    t2.width = w; t2.height = h;
    const tt = t2.getContext('2d');
    tt.drawImage(tmp, 0,0,w,h);
    tctx.globalCompositeOperation='screen';
    tctx.globalAlpha = 0.85;
    tctx.drawImage(t2, 0,0, tmp.width, tmp.height);
    // back to main
    ctx.globalCompositeOperation='screen';
    ctx.globalAlpha = 0.9;
    ctx.drawImage(tmp, 0,0, W, H);
    t2.width=t2.height=1; // GC hint
  }

  // main loop
  let last = now();
  function loop(){
    const t = now();
    const dt = t - last; last = t;
    if(paused){ requestAnimationFrame(loop); return; }

    // subtle vignette clear
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle='rgba(0,0,10,0.2)';
    ctx.fillRect(0,0,W,H);

    // soft axial background glow behind the column
    const bgw = 220*DPR;
    const bgh = crystal.height*1.1;
    const bgrad = ctx.createLinearGradient(CX-bgw*0.5, CY-bgh*0.5, CX+bgw*0.5, CY+bgh*0.5);
    bgrad.addColorStop(0, 'rgba(0,90,255,0.06)');
    bgrad.addColorStop(0.5, 'rgba(0,210,255,0.18)');
    bgrad.addColorStop(1, 'rgba(0,90,255,0.06)');
    ctx.fillStyle=bgrad; ctx.globalAlpha=1; 
    ctx.fillRect(CX-bgw*0.5, CY-bgh*0.5, bgw, bgh);

    // warp amount from dragging
    const wx = (mx - innerWidth*0.5) * 0.002;
    const wy = (my - innerHeight*0.5) * 0.003;

    // draw column facets back-to-front
    for(let layer=0; layer<2; layer++){
      const behind = layer===0;
      for(const f of crystal.column){
        const n = noise2(f.x*0.6, f.y*0.7, t);
        const wobble = 1 + n*0.08;
        const lx = f.x + (behind?-8:8)*DPR + wx*40*DPR;
        const ly = f.y + wy*30*DPR;
        const w = f.w * wobble;
        const h = f.h * (1 + n*0.04);
        const a = behind ? 'rgba(0,179,179,0.7)' : palette.core;
        const b = behind ? '#0080ff' : palette.core2;
        drawFacet(ctx, lx, ly, w, h, t, a, b, 0.22);
      }
    }

    // bright center core
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = palette.white;
    const coreS = 14*DPR;
    ctx.fillRect(CX-coreS, CY-coreS, coreS*2, coreS*2);

    // side shards
    for(const s of crystal.shards){
      const n = noise2(s.x*0.8, s.y*0.8, t+3000);
      const wob = 1 + n*0.12;
      const w = s.w*wob, h = s.h*(1+n*0.05);
      const x = s.x + wx*55*DPR; const y = s.y + wy*45*DPR;
      drawFacet(ctx, x, y, w, h, t, palette.core2, palette.teal, 0.18);
    }

    // particles
    for(const p of particles){
      p.x += p.vx; p.y += p.vy; p.p += p.sp*dt;
      if(p.x < CX-260*DPR || p.x > CX+260*DPR) p.vx *= -1;
      if(p.y < CY-420*DPR || p.y > CY+420*DPR) p.vy *= -1;
      const s = p.s * (0.8 + 0.2*Math.sin(p.p));
      ctx.globalAlpha = p.a * (0.6 + 0.4*Math.sin(p.p*2));
      ctx.fillStyle = p.c;
      ctx.fillRect(p.x-s*0.5, p.y-s*0.5, s, s);
    }

    // faint scanline flares
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = '#7af6ff';
    for(let i=0;i<4;i++){
      const yy = CY + Math.sin((t*0.001+i)*1.3)*H*0.15;
      ctx.fillRect(CX-130*DPR, yy-2, 260*DPR, 4);
    }

    // final bloom
    applyBloom();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>

